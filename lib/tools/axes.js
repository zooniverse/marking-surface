// Generated by CoffeeScript 1.6.3
(function() {
  var AxesTool, Tool, dotRadius, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Tool = window.MarkingSurface.Tool;

  dotRadius = 'Touch' in window ? 20 : 10;

  AxesTool = (function(_super) {
    var downedDot;

    __extends(AxesTool, _super);

    function AxesTool() {
      this['on drag dots'] = __bind(this['on drag dots'], this);
      _ref = AxesTool.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    AxesTool.prototype.lines = null;

    AxesTool.prototype.dots = null;

    AxesTool.prototype.markDefaults = {
      type: 'AXES',
      p0: [-(dotRadius * 2), -(dotRadius * 2)],
      p1: [-(dotRadius * 2), -(dotRadius * 2)],
      p2: [-(dotRadius * 2), -(dotRadius * 2)],
      p3: [-(dotRadius * 2), -(dotRadius * 2)]
    };

    AxesTool.prototype.color = [127, 255, 0];

    AxesTool.prototype.cursors = {
      'dots': 'move'
    };

    AxesTool.prototype.initialize = function() {
      var i;
      this.lines = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 2; i = ++_i) {
          _results.push(this.addShape('line', {
            stroke: "rgb(" + this.color + ")",
            strokeWidth: 2
          }));
        }
        return _results;
      }).call(this);
      return this.dots = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 4; i = ++_i) {
          _results.push(this.addShape('circle', {
            r: dotRadius,
            fill: "rgba(" + this.color + ", 0.25)",
            stroke: "rgb(" + this.color + ")",
            strokeWidth: 2
          }));
        }
        return _results;
      }).call(this);
    };

    AxesTool.prototype.onFirstClick = function(e) {
      var point, points, x, y, _i, _len, _ref1, _results;
      _ref1 = this.pointerOffset(e), x = _ref1.x, y = _ref1.y;
      points = this.drags === 0 ? ['p0', 'p1', 'p2', 'p3'] : ['p2', 'p3'];
      _results = [];
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        point = points[_i];
        _results.push(this.mark.set(point, [x, y]));
      }
      return _results;
    };

    AxesTool.prototype.onFirstDrag = function(e) {
      var point, points, x, y, _i, _len, _ref1, _results;
      _ref1 = this.pointerOffset(e), x = _ref1.x, y = _ref1.y;
      points = this.drags === 0 ? ['p1', 'p3'] : ['p3'];
      _results = [];
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        point = points[_i];
        _results.push(this.mark.set(point, [x, y]));
      }
      return _results;
    };

    AxesTool.prototype.isComplete = function() {
      return this.drags === 2;
    };

    downedDot = NaN;

    AxesTool.prototype['on drag dots'] = function(e) {
      var i, index, s, x, y, _i, _len, _ref1, _ref2, _ref3;
      _ref1 = this.pointerOffset(e), x = _ref1.x, y = _ref1.y;
      _ref2 = this.dots;
      for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
        s = _ref2[i];
        if (s.el === e.target) {
          index = i;
        }
      }
      if ((_ref3 = e.type) === 'mousedown' || _ref3 === 'touchstart') {
        this.downedDot = index;
      }
      return this.mark.set("p" + this.downedDot, [x, y]);
    };

    AxesTool.prototype.render = function() {
      var i, intersection, line, point, _i, _j, _len, _len1, _ref1, _ref2, _ref3;
      _ref1 = ['p0', 'p1', 'p2', 'p3'];
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        point = _ref1[i];
        this.dots[i].attr({
          cx: this.mark[point][0],
          cy: this.mark[point][1]
        });
      }
      this.lines[0].attr({
        x1: this.mark.p0[0],
        y1: this.mark.p0[1],
        x2: this.mark.p1[0],
        y2: this.mark.p1[1]
      });
      this.lines[1].attr({
        x1: this.mark.p2[0],
        y1: this.mark.p2[1],
        x2: this.mark.p3[0],
        y2: this.mark.p3[1]
      });
      intersection = this.getIntersection(this.mark.p0, this.mark.p1, this.mark.p2, this.mark.p3);
      _ref2 = this.lines;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        line = _ref2[_j];
        line.attr({
          'strokeDasharray': intersection != null ? '' : '2, 2'
        });
      }
      if (intersection == null) {
        intersection = [(this.mark.p0[0] + this.mark.p1[0] + this.mark.p2[0] + this.mark.p3[0]) / 4, (this.mark.p0[1] + this.mark.p1[1] + this.mark.p2[1] + this.mark.p3[1]) / 4];
      }
      return (_ref3 = this.controls).moveTo.apply(_ref3, intersection);
    };

    AxesTool.prototype.getIntersection = function(p0, p1, p2, p3) {
      var grads, interX, interY, sortedX, sortedY;
      grads = [(p0[1] - p1[1]) / ((p0[0] - p1[0]) || 0.00001), (p2[1] - p3[1]) / ((p2[0] - p3[0]) || 0.00001)];
      interX = ((p2[1] - p0[1]) + (grads[0] * p0[0] - grads[1] * p2[0])) / (grads[0] - grads[1]);
      interY = grads[0] * (interX - p0[0]) + p0[1];
      sortedX = [p0[0], p1[0], p2[0], p3[0], interX].sort(function(a, b) {
        return a - b;
      });
      sortedY = [p0[1], p1[1], p2[1], p3[1], interY].sort(function(a, b) {
        return a - b;
      });
      if (sortedX[2] !== interX) {
        interX = NaN;
      }
      if (sortedY[2] !== interY) {
        interY = NaN;
      }
      if ((isNaN(interX)) || (isNaN(interY))) {
        return null;
      } else {
        return [interX, interY];
      }
    };

    return AxesTool;

  })(Tool);

  if (typeof window !== "undefined" && window !== null) {
    window.MarkingSurface.AxesTool = AxesTool;
  }

  if (typeof module !== "undefined" && module !== null) {
    module.exports = AxesTool;
  }

}).call(this);
